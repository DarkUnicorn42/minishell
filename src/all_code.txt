/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mwojtcza <mwojtcza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/03 15:03:59 by mwojtcza          #+#    #+#             */
/*   Updated: 2024/10/03 15:04:09 by mwojtcza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int builtin_echo(char **args)
{
    int i;
    int newline;

    i = 1;
    newline = 1;
    if (args[i] && ft_strcmp(args[i], "-n") == 0)
    {
        newline = 0;
        i++;
    }
    while (args[i])
    {
        printf("%s", args[i]);
        if (args[i + 1])
            printf(" ");
        i++;
    }
    if (newline)
        printf("\n");
    return (0);
}

int builtin_pwd(void)
{
    char cwd[PATH_MAX];

    if (getcwd(cwd, sizeof(cwd)) != NULL)
    {
        printf("%s\n", cwd);
        return (0);
    }
    else 
    {
        perror("pwd");
        return (1);
    }
}

int builtin_unset(char **args, t_shell *shell)
{
    int i;
    int exit_code;

    i = 1;
    exit_code = 0;
    while (args[i]) {
        if (!is_valid_identifier(args[i]))
        {
            fprintf(stderr, "unset: '%s': not a valid identifier\n", args[i]);
            exit_code = 1;
        }
        else
            shell->envp = unset_env_value(args[i], shell->envp);
        i++;
    }
    return (exit_code);
}

int	builtin_exit(char **args, t_shell *shell, t_history *history)
{
    cleanup_shell(shell, history);

	if (!args[1])
		exit(shell->exit_code);
	if (!is_numeric(args[1]))
	{
		print_exit_error(args[1], "numeric argument required");
		exit(2);
	}
	if (args[2])
	{
		ft_putstr_fd("minishell: exit: too many arguments\n", STDERR_FILENO);
		shell->exit_code = 1;
		return (1);
	}
    
	exit((unsigned char)ft_atoi(args[1]));
}

int builtin_history(t_history *history)
{
    int i;

    i = 0;
    while (i < history->count)
    {
        printf("%d %s\n", i + 1, history->commands[i]);
        i++;
    }
    return (0);
}

#include "../../include/minishell.h"

int	builtin_cd(char **args, t_shell *shell)
{
	char	*path;
	int		arg_count;

	arg_count = count_args(args);
	if (arg_count > 2)
		return (print_error("cd: too many arguments\n", 1));
	path = get_cd_path(args, shell);
	if (!path)
		return (1);
	if (chdir(path) == -1)
		return (print_error(" No such file or directory\n", 1));
	if (!update_pwd(shell))
		return (1);
	return (0);
}

char	*get_cd_path(char **args, t_shell *shell)
{
	char	*path;

	if (!args[1])
	{
		path = get_env_value("HOME", shell->envp);
		if (!path)
		{
			ft_putstr_fd("cd: HOME not set\n", STDERR_FILENO);
			return (NULL);
		}
	}
	else
		path = args[1];
	return (path);
}

int	update_pwd(t_shell *shell)
{
	char	cwd[PATH_MAX];

	if (getcwd(cwd, sizeof(cwd)) != NULL)
	{
		shell->envp = set_env_value("PWD", cwd, shell->envp);
		if (!shell->envp)
			return (print_error("Error updating PWD\n", 1));
	}
	else
		return (print_error("getcwd failed\n", 0));
	return (1);
}

int	count_args(char **args)
{
	int	count;

	count = 0;
	while (args[count])
		count++;
	return (count);
}

#include "../../include/minishell.h"

int	builtin_env(t_shell *shell)
{
	int	i;

	i = 0;
	while (shell->envp[i])
	{
		ft_putstr_fd(shell->envp[i], STDOUT_FILENO);
		ft_putchar_fd('\n', STDOUT_FILENO);
		i++;
	}
	return (0);
}

char	*get_env_value(const char *name, char **envp)
{
	int		i;
	size_t	len;

	i = 0;
	len = ft_strlen(name);
	while (envp[i])
	{
		if (ft_strncmp(envp[i], name, len) == 0 && envp[i][len] == '=')
			return (&envp[i][len + 1]);
		i++;
	}
	return (NULL);
}

char	*construct_env_entry(const char *key, const char *value)
{
	char	*entry;
	char	*tmp;

	tmp = ft_strjoin(key, "=");
	if (!tmp)
		return (NULL);
	entry = ft_strjoin(tmp, value);
	free(tmp);
	if (!entry)
		return (NULL);
	return (entry);
}

char	**set_env_value(const char *key, const char *value, char **envp)
{
	int		key_len;
	char	*new_entry;
	int		i;

	key_len = ft_strlen(key);
	i = 0;
	while (envp[i])
	{
		if (ft_strncmp(envp[i], key, key_len) == 0 && envp[i][key_len] == '=')
		{
			free(envp[i]);
			new_entry = construct_env_entry(key, value);
			if (!new_entry)
			{
				ft_putstr_fd("Error: malloc failed in set_env_value\n", STDERR_FILENO);
				return (envp);
			}
			envp[i] = new_entry;
			return (envp);
		}
		i++;
	}
	return (add_env_entry(envp, key, value));
}

char	**add_env_entry(char **envp, const char *key, const char *value)
{
	char	**new_envp;
	int		i;

	i = 0;
	while (envp[i])
		i++;
	new_envp = realloc_envp(envp, i + 2);
	if (!new_envp)
		return (envp);
	new_envp[i] = construct_env_entry(key, value);
	if (!new_envp[i])
	{
		ft_putstr_fd("Error: malloc failed in add_env_entry\n", STDERR_FILENO);
		return (envp);
	}
	new_envp[i + 1] = NULL;
	free(envp);
	return (new_envp);
}

char	**realloc_envp(char **envp, int new_size)
{
	char	**new_envp;
	int		i;

	new_envp = malloc(sizeof(char *) * new_size);
	if (!new_envp)
	{
		ft_putstr_fd("Error: malloc failed in realloc_envp\n", STDERR_FILENO);
		return (NULL);
	}
	i = 0;
	while (envp[i])
	{
		new_envp[i] = envp[i];
		i++;
	}
	return (new_envp);
}

char	**unset_env_value(const char *key, char **envp)
{
	int		key_len;
	int		i;
	int		j;

	key_len = ft_strlen(key);
	i = 0;
	while (envp[i])
	{
		if (ft_strncmp(envp[i], key, key_len) == 0 && envp[i][key_len] == '=')
		{
			free(envp[i]);
			j = i;
			while (envp[j])
			{
				envp[j] = envp[j + 1];
				j++;
			}
			return (envp);
		}
		i++;
	}
	return (envp);
}

#include "../../include/minishell.h"


int	builtin_export(char **args, t_shell *shell)
{
	int		i;
	int		exit_code;

	if (!args[1])
		return (print_export_env(shell));
	exit_code = 0;
	i = 1;
	while (args[i])
	{
		if (!process_export_arg(args[i], shell))
			exit_code = 1;
		i++;
	}
	return (exit_code);
}

int	process_export_arg(char *arg, t_shell *shell)
{
	char	*key;
	char	*value;
	int		result;

	result = parse_export_arg(arg, &key, &value);
	if (result == -1)
		return (print_error("malloc error\n", 1));
	if (result == 0)
		return (print_export_id_error(arg));
	if (update_envp(shell->envp, key, value) == -1)
	{
		if (expand_envp(shell, arg))
			return (print_error("malloc error\n", 1));
	}
	free(key);
	free(value);
	return (1);
}

int expand_envp(t_shell *shell, char *new_var)
{
    int count = 0;

    while (shell->envp[count])
        count++;

    char **new_envp = malloc((count + 2) * sizeof(char *));
    if (!new_envp) {
        perror("malloc");
        return 1;
    }

    for (int i = 0; i < count; i++)
        new_envp[i] = shell->envp[i];

    new_envp[count] = ft_strdup(new_var);
    if (!new_envp[count]) {
        perror("malloc");
        free(new_envp);
        return 1;
    }
    new_envp[count + 1] = NULL;

    free(shell->envp);
    shell->envp = new_envp;

    return 0;
}

int update_envp(char **envp, char *key, char *new_value)
{
    for (int i = 0; envp[i]; i++) {
        if (ft_strncmp(envp[i], key, ft_strlen(key)) == 0 && envp[i][ft_strlen(key)] == '=') {
            free(envp[i]);
            envp[i] = ft_strdup(new_value);
            if (!envp[i]) {
                perror("malloc");
                return 1;
            }
            return 0;
        }
    }
    return -1;
}

int	print_export_env(t_shell *shell)
{
	int	i;

	i = 0;
	while (shell->envp[i])
	{
		ft_putstr_fd("declare -x ", STDOUT_FILENO);
		ft_putendl_fd(shell->envp[i], STDOUT_FILENO);
		i++;
	}
	return (0);
}

int	parse_export_arg(char *arg, char **key, char **value)
{
	char	*equal_sign;

	equal_sign = ft_strchr(arg, '=');
	if (equal_sign)
	{
		*key = ft_substr(arg, 0, equal_sign - arg);
		*value = ft_strdup(equal_sign + 1);
	}
	else
	{
		*key = ft_strdup(arg);
		*value = NULL;
	}
	if (!*key || (equal_sign && !*value))
		return (-1);
	if (!is_valid_identifier(*key))
		return (0);
	return (1);
}

int	print_export_id_error(char *identifier)
{
	ft_putstr_fd("export: `", STDERR_FILENO);
	ft_putstr_fd(identifier, STDERR_FILENO);
	ft_putstr_fd("': not a valid identifier\n", STDERR_FILENO);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mwojtcza <mwojtcza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/03 15:04:10 by mwojtcza          #+#    #+#             */
/*   Updated: 2024/10/03 15:04:12 by mwojtcza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	execute_commands(t_command *commands, t_shell *shell, t_history *history)
{
	t_command	*cmd;
	int			input_fd;
	pid_t		last_pid;

	input_fd = STDIN_FILENO;
	last_pid = -1;
	cmd = commands;
	while (cmd)
	{
		if (is_builtin_parent(cmd->args[0]) && !cmd->next)
			shell->exit_code = execute_builtin(cmd, shell, history);
		else
		{
			if (!execute_command(cmd, shell, history, &input_fd, &last_pid))
				return (set_exit_code(shell, 1));
		}
		cmd = cmd->next;
	}
	wait_for_children(shell, last_pid);
	return (0);
}

int	execute_command(t_command *cmd, t_shell *shell, t_history *history,
					int *input_fd, pid_t *last_pid)
{
	int		pipe_fd[2];
	pid_t	pid;

	if (cmd->next && create_pipe(pipe_fd) == -1)
		return (0);
	pid = fork_process();
	if (pid == -1)
		return (0);
	if (pid == 0)
		execute_child(cmd, shell, history, *input_fd, pipe_fd);
	else
		execute_parent(cmd, input_fd, pipe_fd, pid, last_pid);
	return (1);
}

void	execute_child(t_command *cmd, t_shell *shell, t_history *history,
					  int input_fd, int pipe_fd[2])
{
	setup_child_io(cmd, input_fd, pipe_fd);
	if (handle_redirections(cmd) == -1)
		exit(1);
	if (is_builtin(cmd->args[0]))
		shell->exit_code = execute_builtin(cmd, shell, history);
	else
		execute_external(cmd, shell);
	exit(shell->exit_code);
}

void	execute_parent(t_command *cmd, int *input_fd, int pipe_fd[2],
					   pid_t pid, pid_t *last_pid)
{
	if (*input_fd != STDIN_FILENO)
		close(*input_fd);
	if (cmd->next)
	{
		close(pipe_fd[1]);
		*input_fd = pipe_fd[0];
	}
	*last_pid = pid;
}

void	execute_external(t_command *command, t_shell *shell)
{
	char	*full_path;

	full_path = get_full_path(command, shell);
	if (!full_path)
		exit(127);
	execute_command_full_path(full_path, command->args, shell->envp);
}

#include "../../include/minishell.h"

int	is_builtin_parent(char *cmd)
{
	if (!ft_strcmp(cmd, "cd") || !ft_strcmp(cmd, "export") ||
		!ft_strcmp(cmd, "unset") || !ft_strcmp(cmd, "exit"))
		return (1);
	return (0);
}

int	is_builtin(char *cmd)
{
	if (!ft_strcmp(cmd, "echo") || !ft_strcmp(cmd, "pwd") ||
		!ft_strcmp(cmd, "env") || !ft_strcmp(cmd, "history"))
		return (1);
	return (0);
}

int execute_builtin(t_command *command, t_shell *shell, t_history *history)
{
    int i = 0;

    while (command->args[i])
    {
        if (command->arg_types[i] != TOKEN_SINGLE_QUOTED)
            command->args[i] = expand_argument(command->args[i], shell);
        i++;
    }
    return run_builtin_command(command, shell, history);
}

int	run_builtin_command(t_command *command, t_shell *shell, t_history *history)
{
	if (ft_strcmp(command->args[0], "echo") == 0)
		return (builtin_echo(command->args));
	else if (ft_strcmp(command->args[0], "cd") == 0)
		return (builtin_cd(command->args, shell));
	else if (ft_strcmp(command->args[0], "pwd") == 0)
		return (builtin_pwd());
	else if (ft_strcmp(command->args[0], "export") == 0)
		return (builtin_export(command->args, shell));
	else if (ft_strcmp(command->args[0], "unset") == 0)
		return (builtin_unset(command->args, shell));
	else if (ft_strcmp(command->args[0], "env") == 0)
		return (builtin_env(shell));
	else if (ft_strcmp(command->args[0], "exit") == 0)
		return (builtin_exit(command->args, shell, history));
	else if (ft_strcmp(command->args[0], "history") == 0)
		return (builtin_history(history));
	return (0);
}
#include "../../include/minishell.h"

char	*get_full_path(t_command *command, t_shell *shell)
{
	char	*full_path;

	if (ft_strchr(command->args[0], '/'))
	{
		full_path = ft_strdup(command->args[0]);
		if (!full_path)
			print_error("minishell: memory allocation error\n", 1);
		if (!check_file_access(full_path))
			return (NULL);
	}
	else
	{
		full_path = search_in_path(command->args[0], shell->envp);
		if (!full_path)
			return (NULL);
	}
	return (full_path);
}

char	*find_executable_path(char **paths, char *cmd)
{
	int		i;
	char	*full_path;

	i = 0;
	while (paths[i])
	{
		full_path = join_path_cmd(paths[i], cmd);
		if (check_executable(full_path, cmd))
			return (full_path);
		free(full_path);
		i++;
	}
	return (NULL);
}

char	*search_in_path(char *cmd, char **envp)
{
	char	*path_env;
	char	**paths;
	char	*full_path;

	path_env = get_env_value("PATH", envp);
	paths = ft_split(path_env, ':');
	full_path = find_executable_path(paths, cmd);
	free_string_array(paths);
	if (!full_path)
		print_exit_error(cmd, ": command not found\n");
	return (full_path);
}

#include "../../include/minishell.h"

char	*join_path_cmd(char *path, char *cmd)
{
	char	*temp_path;
	char	*full_path;

	temp_path = ft_strjoin(path, "/");
	full_path = ft_strjoin(temp_path, cmd);
	free(temp_path);
	return (full_path);
}

int	check_executable(char *full_path, char *cmd)
{
	if (access(full_path, X_OK) == 0)
		return (1);
	else if (access(full_path, F_OK) == 0)
	{
		print_exit_error(cmd, ": permission denied\n");
		return (0);
	}
	return (0);
}

void	execute_command_full_path(char *full_path, char **args, char **envp)
{
	execve(full_path, args, envp);
	print_exit_error(full_path, ": execve error\n");
	free(full_path);
	exit(1);
}

int	check_file_access(char *full_path)
{
	if (access(full_path, F_OK) != 0)
	{
		print_exit_error(full_path, ": No such file or directory\n");
		free(full_path);
		return (0);
	}
	else if (access(full_path, X_OK) != 0)
	{
		print_exit_error(full_path, ": Permission denied\n");
		free(full_path);
		return (0);
	}
	return (1);
}


#include "../include/minishell.h"

char	*expand_variable(const char *str, int *i, t_shell *shell)
{
	int		var_start;
	char	*var_name;
	char	*expansion;
	char	*env_value;

	var_start = *i + 1;
	while (str[*i + 1] && (ft_isalnum(str[*i + 1]) || str[*i + 1] == '_'))
		(*i)++;
	var_name = ft_substr(str, var_start, *i + 1 - var_start);
	if (!var_name)
	{
		ft_putstr_fd("Error: malloc failed in expand_variable\n", 2);
		return (NULL);
	}
	env_value = get_env_value(var_name, shell->envp);
	if (env_value)
		expansion = ft_strdup(env_value);
	else
		expansion = ft_strdup("");
	free(var_name);
	(*i)++;
	return (expansion);
}

char	*expand_exit_code(t_shell *shell, int *i)
{
	*i += 2;
	return (ft_itoa(shell->exit_code));
}

char	*expand_variables(const char *str, t_shell *shell)
{
	char	*result;
	int		i;

	i = 0;
	result = ft_strdup("");
	if (!result)
	{
		ft_putstr_fd("Error: malloc failed in expand_variables\n", 2);
		return (NULL);
	}
	while (str[i])
	{
		result = append_expanded_token(result, str, &i, shell);
		if (!result)
			return (NULL);
	}
	return (result);
}

char	*append_expanded_token(char *result, const char *str, int *i, t_shell *shell)
{
	char	*expansion;
	char	*temp;

	if (str[*i] == '$')
		expansion = get_expansion(str, i, shell);
	else
		expansion = ft_substr(str, (*i)++, 1);
	if (!expansion)
	{
		free(result);
		return (NULL);
	}
	temp = ft_strjoin(result, expansion);
	free(result);
	free(expansion);
	if (!temp)
	{
		ft_putstr_fd("Error: malloc failed in append_expanded_token\n", 2);
		return (NULL);
	}
	return (temp);
}

char	*get_expansion(const char *str, int *i, t_shell *shell)
{
	char	*expansion;

	if (str[*i + 1] == '?')
		expansion = expand_exit_code(shell, i);
	else if (ft_isalpha(str[*i + 1]) || str[*i + 1] == '_')
		expansion = expand_variable(str, i, shell);
	else
	{
		expansion = ft_strdup("$");
		(*i)++;
	}
	return (expansion);
}

char	*expand_argument(char *arg, t_shell *shell)
{
	char	*expanded_arg;

	expanded_arg = expand_variables(arg, shell);
	if (!expanded_arg)
	{
		ft_putstr_fd("Error: malloc failed in expand_argument\n", STDERR_FILENO);
		return (arg);
	}
	free(arg);
	arg = NULL;
	return (expanded_arg);
}

#include "../include/minishell.h"

int	add_history_entry(char *input, t_history *history)
{
	add_history(input);
	if (history->count >= history->capacity)
	{
		if (!resize_history(history))
			return (0);
	}
	history->commands[history->count] = ft_strdup(input);
	if (!history->commands[history->count])
		return (0);
	history->count++;
	return (1);
}

int	resize_history(t_history *history)
{
	char	**new_commands;
	int		j;
	int		new_capacity;

	new_capacity = history->capacity * 2;
	new_commands = malloc(sizeof(char *) * new_capacity);
	if (!new_commands)
		return (0);
	j = 0;
	while (j < history->count)
	{
		new_commands[j] = history->commands[j];
		j++;
	}
    // j = 0;
    // while (j < history->count)
	// {
    //     free(history->commands[j]);
	// 	j++;
	// }
	free(history->commands);
	history->commands = new_commands;
	history->capacity = new_capacity;
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mwojtcza <mwojtcza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/03 15:04:14 by mwojtcza          #+#    #+#             */
/*   Updated: 2024/10/03 15:04:14 by mwojtcza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_token	*lexer(const char *input)
{
	t_token	*tokens;
	size_t	i;

	tokens = NULL;
	i = 0;
	while (input[i] != '\0')
	{
		skip_whitespace(input, &i);
		if (input[i] == '\0')
			break ;
		if (is_operator_char(input[i]))
			handle_operator(input, &i, &tokens);
		else
		{
			if (!handle_word(input, &i, &tokens))
			{
				free_tokens(tokens);
				return (NULL);
			}
		}
	}
	add_token(&tokens, create_token(TOKEN_EOF, NULL));
	return (tokens);
}

int	handle_word(const char *input, size_t *i, t_token **tokens)
{
	t_token	*new_token;

	new_token = collect_word_token(input, i);
	if (!new_token)
		return (0);
	add_token(tokens, new_token);
	return (1);
}

void	handle_operator(const char *input, size_t *i, t_token **tokens)
{
	t_token_type	type;
	t_token			*new_token;

	type = identify_operator(input, i);
	new_token = create_token(type, NULL);
	if (!new_token)
	{
		free_tokens(*tokens);
		return ;
	}
	add_token(tokens, new_token);
}

int	handle_quotes(const char *input, size_t *i, char **word, int *quote_type)
{
	char	*quoted_content;
	char	*temp;
	char	quote_char;

	quote_char = input[*i];
	quoted_content = collect_quoted(input, i, quote_char);
	if (!quoted_content)
		return (0);
	temp = join_and_free(*word, quoted_content);
	if (!temp)
	{
		free(*word);
		return (0);
	}
	*word = temp;
	if (quote_char == '\'' && *quote_type != 2)
		*quote_type = 1;
	else if (quote_char == '"' && *quote_type != 1)
		*quote_type = 2;
	return (1);
}

int	handle_unquoted(const char *input, size_t *i, char **word)
{
	size_t	start;
	char	*substr;
	char	*temp;

	start = *i;
	while (input[*i] != '\0' && !isspace((unsigned char)input[*i])
		&& !is_operator_char(input[*i]) && input[*i] != '\''
		&& input[*i] != '"')
		(*i)++;
	substr = ft_substr(input, start, *i - start);
	if (!substr)
		return (0);
	temp = join_and_free(*word, substr);
	if (!temp)
	{
		free(*word);
		return (0);
	}
	*word = temp;
	return (1);
}

#include "../../include/minishell.h"

t_token	*collect_word_token(const char *input, size_t *i)
{
	char	*word;
	t_token	*token;
	int		quote_type;

	word = ft_strdup("");
	if (!word)
		return (NULL);
	quote_type = 0;
	if (!parse_word(input, i, &word, &quote_type))
	{
		free(word);
		return (NULL);
	}
	token = create_token_quote(quote_type, word);
	if (!token)
	{
		free(word);
		return (NULL);
	}
	return (token);
}

int	parse_word(const char *input, size_t *i, char **word, int *quote_type)
{
	while (input[*i] != '\0' && !isspace((unsigned char)input[*i])
		&& !is_operator_char(input[*i]))
	{
		if (input[*i] == '\'' || input[*i] == '"')
		{
			if (!handle_quotes(input, i, word, quote_type))
				return (0);
		}
		else
		{
			if (!handle_unquoted(input, i, word))
				return (0);
		}
	}
	return (1);
}

t_token	*create_token_quote(int quote_type, char *word)
{
	if (quote_type == 1)
		return (create_token(TOKEN_SINGLE_QUOTED, word));
	else if (quote_type == 2)
		return (create_token(TOKEN_DOUBLE_QUOTED, word));
	else
		return (create_token(TOKEN_WORD, word));
}

t_token	*create_token(t_token_type type, char *value)
{
	t_token	*token;

	token = malloc(sizeof(t_token));
	if (!token)
		return (NULL);
	token->type = type;
	token->value = value;
	token->next = NULL;
	return (token);
}

void	add_token(t_token **tokens, t_token *new_token)
{
	t_token	*temp;

	if (*tokens == NULL)
		*tokens = new_token;
	else
	{
		temp = *tokens;
		while (temp->next != NULL)
			temp = temp->next;
		temp->next = new_token;
	}
}


#include "../../include/minishell.h"

t_token_type	identify_operator(const char *input, size_t *i)
{
	if (input[*i] == '|')
	{
		(*i)++;
		return (TOKEN_PIPE);
	}
	else if (input[*i] == '<')
	{
		(*i)++;
		if (input[*i] == '<')
		{
			(*i)++;
			return (TOKEN_HEREDOC);
		}
		return (TOKEN_REDIRECT_IN);
	}
	else if (input[*i] == '>')
	{
		(*i)++;
		if (input[*i] == '>')
		{
			(*i)++;
			return (TOKEN_APPEND);
		}
		return (TOKEN_REDIRECT_OUT);
	}
	return (TOKEN_EOF);
}

char	*collect_quoted(const char *input, size_t *i, char quote_char)
{
	size_t	start;
	char	*quoted;

	(*i)++;
	start = *i;
	while (input[*i] != '\0' && input[*i] != quote_char)
		(*i)++;
	if (input[*i] != quote_char)
	{
		ft_putstr_fd("Error: Unclosed quote\n", STDERR_FILENO);
		return (NULL);
	}
	quoted = ft_substr(input, start, *i - start);
	if (!quoted)
		return (NULL);
	(*i)++;
	return (quoted);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mwojtcza <mwojtcza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/03 15:03:54 by mwojtcza          #+#    #+#             */
/*   Updated: 2024/10/03 15:03:54 by mwojtcza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/minishell.h"

void	print_welcome_message(void)
{
	printf("\e[38;5;113m***************************************************************\n");
	printf("\e[38;5;113m*  .-.   .-..-..-. .-..-.    .----..-. .-..----..-.   .-.     *\n");
	printf("\e[38;5;113m*  |  `.'  || ||  `| || |   { {__  | {_} || {_  | |   | |     *\n");
	printf("\e[38;5;114m*  | |╲ /| || || |╲  || |   .-._} }| { } || {__ | `--.| `--.  *\n");
	printf("\e[38;5;114m*  `-' ` `-'`-'`-' `-'`-'   `----' `-' `-'`----'`----'`----'  *\n");
	printf("\e[38;5;114m***************************************************************\n");
	printf("\e[38;5;115m*        :::      :::::::: ***        Hello!  Welcome to      *\n");
	printf("\e[38;5;115m*      :+:      :+:    :+: ***          our minishell!        *\n");
	printf("\e[38;5;115m*    +:+ +:+         +:+   ************************************\n");
	printf("\e[38;5;116m*  +#+  +:+       +#+      ***     ★ ★ ★  Authors:  ★ ★ ★     *\n");
	printf("\e[38;5;116m*+#+#+#+#+#+   +#+         ************************************\n");
	printf("\e[38;5;116m*     #+#    #+#           ***            mwojtcza            *\n");
	printf("\e[38;5;117m*    ###   ########.fr     ***            mszlicht            *\n");
	printf("\e[38;5;117m***************************************************************\n\n");
}

int	init_shell(t_shell *shell, char **envp, t_history *history)
{
	shell->envp = duplicate_envp(envp);
	if (!shell->envp)
	{
		printf("Failed to initialize environment variables\n");
		return (1);
	}
	shell->exit_code = 0;
	setup_signals();
	history->commands = malloc(sizeof(char *) * INITIAL_CAPACITY);
	if (!history->commands)
	{
		printf("Failed to allocate history\n");
		return (1);
	}
	history->count = 0;
	history->capacity = INITIAL_CAPACITY;
	//print_welcome_message();
	return (0);
}

void	process_input(char *input, t_shell *shell, t_history *history)
{
	t_token		*tokens;
	t_command	*commands;

	if (input && *input)
	{
		if (!add_history_entry(input, history))
		{
			ft_putstr_fd("Memory allocation failed for command history\n",
						 STDERR_FILENO);
			free(input);
			return ;
		}
	}
	tokens = lexer(input);
	if (!tokens)
	{
		free(input);
		return ;
	}
	commands = parse_tokens(tokens);
	if (!commands)
	{
		free_tokens(tokens);
		free(input);
		return ;
	}
	execute_commands(commands, shell, history);
	free_commands(commands);
	free_tokens(tokens);
	free(input);
}

void	cleanup_shell(t_shell *shell, t_history *history)
{
	int	i;

	i = 0;
	while (i < history->count)
	{
		free(history->commands[i]);
		i++;
	}
	free(history->commands);
	//free(history);
	i = 0;
	while (shell->envp[i] != NULL)
	{
		free(shell->envp[i]);
		i++;
	}
	free(shell->envp);
}

// void	cleanup_shell(t_shell *shell, t_history *history)
// {
// 	int	i;

// 	// Free command history
// 	if (history->commands)
// 	{
// 		i = 0;
// 		while (i < history->count)
// 		{
// 			free(history->commands[i]);
// 			i++;
// 		}
// 		free(history->commands);
// 		history->commands = NULL;
// 	}

// 	// Free shell environment variables
// 	if (shell->envp)
// 	{
// 		i = 0;
// 		while (shell->envp[i])
// 		{
// 			free(shell->envp[i]);
// 			i++;
// 		}
// 		free(shell->envp);
// 		shell->envp = NULL;
// 	}

// 	// Free current_dir if allocated
// 	if (shell->current_dir)
// 	{
// 		free(shell->current_dir);
// 		shell->current_dir = NULL;
// 	}

// 	// Add any other necessary cleanup here
// } 

int	main(int argc, char **argv, char **envp)
{
	t_shell		shell;
	t_history	history;
	char		*input;

	(void)argc;
	(void)argv;
	if (init_shell(&shell, envp, &history))
		return (1);
	while (1)
	{
		input = readline("📟 \e[0;32m(s)hell >> \e[0m");
		if (input == NULL)
		{
			printf(" ");
			// printf("\n\n\e[0;32mExiting shell...\e[0m\n");
			// printf("\n\e[1;32m✖️ Shell closed.\e[0m\n\n");
			break ;
		}
		process_input(input, &shell, &history);
	}
	cleanup_shell(&shell, &history);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mwojtcza <mwojtcza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/03 15:04:18 by mwojtcza          #+#    #+#             */
/*   Updated: 2024/10/03 15:07:27 by mwojtcza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_command	*parse_tokens(t_token *tokens)
{
	t_command	*commands;
	t_command	*current_command;

	commands = NULL;
	current_command = NULL;
	while (tokens && tokens->type != TOKEN_EOF)
	{
		if (is_word_token(tokens->type))
		{
			if (!current_command)
				current_command = start_new_command(&commands);
			if (!current_command)
				return (NULL);
			add_argument(current_command, tokens->value, tokens->type);
		}
		else if (tokens->type == TOKEN_PIPE)
			current_command = NULL;
		else if (is_redirection(tokens->type))
		{
			if (!handle_redirection(&tokens, current_command, &commands))
				return (NULL);
		}
		tokens = tokens->next;
	}
	return (commands);
}

t_command	*start_new_command(t_command **commands)
{
	t_command	*new_command;

	new_command = create_command();
	if (!new_command)
	{
		free_commands(*commands);
		return (NULL);
	}
	add_command(commands, new_command);
	return (new_command);
}

t_command	*create_command()
{
	t_command	*cmd;

	cmd = malloc(sizeof(t_command));
	if (!cmd)
		return (NULL);
	cmd->args = malloc(sizeof(char *));
	cmd->arg_types = malloc(sizeof(t_token_type));
	if (!cmd->args || !cmd->arg_types)
	{
		free_command(cmd);
		return (NULL);
	}
	cmd->args[0] = NULL;
	cmd->redirections = NULL;
	cmd->next = NULL;
	return (cmd);
}

void	add_command(t_command **commands, t_command *new_command)
{
	t_command	*temp;

	if (*commands == NULL)
		*commands = new_command;
	else
	{
		temp = *commands;
		while (temp->next != NULL)
			temp = temp->next;
		temp->next = new_command;
	}
}

void	add_argument(t_command *command, char *arg, t_token_type type)
{
	int				i;
	char			**new_args;
	t_token_type	*new_arg_types;

	i = 0;
	while (command->args && command->args[i])
		i++;
	new_args = realloc_arguments(command->args, i, arg);
	new_arg_types = realloc_arg_types(command->arg_types, i, type);
	if (!new_args || !new_arg_types)
	{
		free(new_args);
		free(new_arg_types);
		return ;
	}
	command->args = new_args;
	command->arg_types = new_arg_types;
}

#include "../../include/minishell.h"

char	**realloc_arguments(char **args, int i, char *arg)
{
	char	**new_args;
	int		j;

	new_args = malloc(sizeof(char *) * (i + 2));
	if (!new_args)
		return (NULL);
	j = 0;
	while (j < i)
	{
		new_args[j] = args[j];
		j++;
	}
	new_args[i] = ft_strdup(arg);
	if (!new_args[i])
		return (NULL);
	new_args[i + 1] = NULL;
	free(args);
	return (new_args);
}

t_token_type	*realloc_arg_types(t_token_type *arg_types, int i,
									t_token_type type)
{
	t_token_type	*new_arg_types;
	int				j;

	new_arg_types = malloc(sizeof(t_token_type) * (i + 1));
	if (!new_arg_types)
		return (NULL);
	j = 0;
	while (j < i)
	{
		new_arg_types[j] = arg_types[j];
		j++;
	}
	new_arg_types[i] = type;
	free(arg_types);
	return (new_arg_types);
}

void	free_arguments(char **args)
{
	int	i;

	if (args)
	{
		i = 0;
		while (args[i])
		{
			free(args[i]);
			i++;
		}
		free(args);
	}
}

void	free_commands(t_command *commands)
{
	t_command	*temp;

	while (commands)
	{
		temp = commands;
		commands = commands->next;
		free_command(temp);
	}
}

void	free_command(t_command *command)
{
	free_arguments(command->args);
	if (command->arg_types)
		free(command->arg_types);
	free_redirections(command->redirections);
	free(command);
}

#include "../../include/minishell.h"

int	handle_redirection(t_token **tokens, t_command *current_command,
						t_command **commands)
{
	t_token_type	redir_type;

	redir_type = (*tokens)->type;
	(*tokens) = (*tokens)->next;
	if (!(*tokens) || !is_word_token((*tokens)->type))
	{
		ft_putstr_fd("Error: Expected delimiter after redirection\n",
					 STDERR_FILENO);
		free_commands(*commands);
		return (0);
	}
	if (!current_command)
	{
		current_command = start_new_command(commands);
		if (!current_command)
			return (0);
	}
	add_redirection(current_command, redir_type, (*tokens)->value);
	return (1);
}

void	add_redirection(t_command *command, t_token_type type, char *file)
{
	t_redirection	*redir;
	t_redirection	*temp;

	redir = malloc(sizeof(t_redirection));
	if (!redir)
		return ;
	redir->type = type;
	redir->file = ft_strdup(file);
	redir->next = NULL;
	if (!command->redirections)
		command->redirections = redir;
	else
	{
		temp = command->redirections;
		while (temp->next)
			temp = temp->next;
		temp->next = redir;
	}
}

int	is_redirection(t_token_type type)
{
	return (type == TOKEN_REDIRECT_IN || type == TOKEN_REDIRECT_OUT
			|| type == TOKEN_HEREDOC || type == TOKEN_APPEND);
}

int	is_word_token(t_token_type type)
{
	return (type == TOKEN_WORD || type == TOKEN_SINGLE_QUOTED
			|| type == TOKEN_DOUBLE_QUOTED);
}

//pipes.c

#include "../include/minishell.h"

int	create_pipe(int pipe_fd[2])
{
	if (pipe(pipe_fd) == -1)
	{
		ft_putstr_fd("Error: pipe failed\n", STDERR_FILENO);
		return (-1);
	}
	return (0);
}

pid_t	fork_process(void)
{
	pid_t	pid;

	pid = fork();
	if (pid == -1)
		ft_putstr_fd("Error: fork failed\n", STDERR_FILENO);
	return (pid);
}

int	parent_process(int input_fd, int pipe_fd[2], t_command *cmd)
{
	if (input_fd != STDIN_FILENO)
		close(input_fd);
	if (cmd->next)
	{
		close(pipe_fd[1]);
		return (pipe_fd[0]);
	}
	return (STDIN_FILENO);
}

void wait_for_children(t_shell *shell, pid_t last_pid)
{
    int status;
    pid_t pid;

    while ((pid = wait(&status)) > 0)
    {
        if (pid == last_pid)
        {
            if (WIFEXITED(status))
                shell->exit_code = WEXITSTATUS(status);
            else if (WIFSIGNALED(status))
                shell->exit_code = 128 + WTERMSIG(status);
            else
                shell->exit_code = 1; // Default exit code
        }
    }
}

void	setup_child_io(t_command *cmd, int input_fd, int pipe_fd[2])
{
	if (input_fd != STDIN_FILENO)
	{
		dup2(input_fd, STDIN_FILENO);
		close(input_fd);
	}
	if (cmd->next)
	{
		close(pipe_fd[0]);
		dup2(pipe_fd[1], STDOUT_FILENO);
		close(pipe_fd[1]);
	}
}
//redirections.c
#include "../include/minishell.h"

int handle_redirections(t_command *command)
{
    t_redirection *redir;
    int fd;

    redir = command->redirections;
    while (redir)
    {
        fd = open_file_for_redirection(redir);
        if (fd == -1)
        {
            print_exit_error(redir->file, strerror(errno));
            return (-1);
        }
        if (dup2(fd, get_dup_fd(redir->type)) == -1)
        {
            ft_putstr_fd("minishell: dup2 error\n", STDERR_FILENO);
            close(fd);
            return (-1);
        }
        close(fd);
        redir = redir->next;
    }
    return (0);
}

int	get_dup_fd(t_token_type type)
{
	if (type == TOKEN_REDIRECT_IN || type == TOKEN_HEREDOC)
		return (STDIN_FILENO);
	return (STDOUT_FILENO);
}

int open_file_for_redirection(t_redirection *redir)
{
    int fd;

    if (redir->type == TOKEN_REDIRECT_IN)
        fd = open(redir->file, O_RDONLY);
    else if (redir->type == TOKEN_REDIRECT_OUT)
        fd = open(redir->file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    else if (redir->type == TOKEN_APPEND)
        fd = open(redir->file, O_WRONLY | O_CREAT | O_APPEND, 0644);
    else if (redir->type == TOKEN_HEREDOC)
        fd = handle_heredoc(redir->file);
    else
        return (-1);
    if (fd == -1)
        return (-1);
    return (fd);
}

int	handle_heredoc(char *delimiter)
{
	int		pipe_fd[2];
	char	*line;

	if (pipe(pipe_fd) == -1)
	{
		ft_putstr_fd("Error: pipe failed\n", STDERR_FILENO);
		return (-1);
	}
	while (1)
	{
		ft_putstr_fd("> ", STDOUT_FILENO);
		line = get_next_line(STDIN_FILENO);
		if (!line)
			break;
		if (ft_strncmp(line, delimiter, ft_strlen(delimiter)) == 0 &&
			line[ft_strlen(delimiter)] == '\n')
		{
			free(line);
			break;
		}
		ft_putstr_fd(line, pipe_fd[1]);
		free(line);
	}
	close(pipe_fd[1]);
	return (pipe_fd[0]);
}

void	free_redirections(t_redirection *redir)
{
	t_redirection	*next_redir;

	while (redir)
	{
		next_redir = redir->next;
		if (redir->file)
			free(redir->file);
		free(redir);
		redir = next_redir;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mszlicht <mszlicht@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/10 18:08:13 by mszlicht          #+#    #+#             */
/*   Updated: 2024/10/10 18:47:32 by mszlicht         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/minishell.h"

void handle_sigquit(int sig)
{
    if (sig == SIGQUIT)
    {}
}

void handle_sigint(int sig)
{
    (void)sig;
    write(STDOUT_FILENO, "\n", 1);
    rl_on_new_line();
    rl_redisplay();
}

void ignore_sigquit() {
    struct sigaction sa_quit;

    sigemptyset(&sa_quit.sa_mask);
    sa_quit.sa_handler = SIG_IGN;
    sa_quit.sa_flags = 0;

    if (sigaction(SIGQUIT, &sa_quit, NULL) == -1) {
        perror("sigaction SIGQUIT");
        _exit(1);
    }
}

void setup_signals(void) {
    struct sigaction sa_int;

    sigemptyset(&sa_int.sa_mask);
    sa_int.sa_handler = handle_sigint;
    sa_int.sa_flags = SA_RESTART;

    if (sigaction(SIGINT, &sa_int, NULL) == -1) {
        perror("sigaction SIGINT");
        _exit(1);
    }

    ignore_sigquit();
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mwojtcza <mwojtcza@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/03 15:04:23 by mwojtcza          #+#    #+#             */
/*   Updated: 2024/10/03 15:04:23 by mwojtcza         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/minishell.h"

void	print_tokens(t_token *tokens)
{
	t_token	*current;

	current = tokens;
	while (current != NULL)
	{
		printf("Token: Type = %d, Value = %s\n", current->type, current->value);
		current = current->next;
	}
}

void	free_tokens(t_token *tokens)
{
	t_token	*temp;

	while (tokens)
	{
		temp = tokens;
		tokens = tokens->next;
		if (temp->value)
        {
            free(temp->value);
            temp->value = NULL;
        }
		free(temp);
		temp = NULL;
	}
}

char	**duplicate_envp(char **envp)
{
	int		count;
	char	**new_envp;

	count = 0;
	while (envp[count])
		count++;
	new_envp = malloc((count + 1) * sizeof(char *));
	if (!new_envp)
		return (NULL);
	if (!copy_envp(envp, new_envp, count))
		return (NULL);
	new_envp[count] = NULL;
	return (new_envp);
}

int	copy_envp(char **envp, char **new_envp, int count)
{
	int	i;

	i = 0;
	while (i < count)
	{
		new_envp[i] = ft_strdup(envp[i]);
		if (!new_envp[i])
		{
			while (--i >= 0)
				free(new_envp[i]);
			free(new_envp);
			return (0);
		}
		i++;
	}
	return (1);
}

char *ft_strncat_char(char *str, char c) {
    size_t len = ft_strlen(str);
    char *new_str = malloc(len + 2);
    if (!new_str) {
        perror("malloc");
        return NULL;
    }
    ft_strcpy(new_str, str);
    new_str[len] = c;
    new_str[len + 1] = '\0';
    return new_str;
}

char *join_and_free(char *str1, char *str2)
{
    char *result;

    result = ft_strjoin(str1, str2);
    free(str1);
    free(str2);
    return result;
}

void skip_whitespace(const char *input, size_t *i)
{
    while (input[*i] == ' ' || input[*i] == '\t')
        (*i)++;
}

int is_operator_char(char c)
{
    return (c == '|' || c == '<' || c == '>' || c == ';');
}

int	set_exit_code(t_shell *shell, int code)
{
	shell->exit_code = code;
	return (code);
}

void	free_string_array(char **array)
{
	int	i;

	i = 0;
	while (array[i])
	{
		free(array[i]);
		array[i] = NULL;
		i++;
	}
	free(array);
	array = NULL;
}

int is_valid_identifier(const char *str)
{
    int i;

    if (!str || !str[0] || (!ft_isalpha(str[0]) && str[0] != '_'))
        return (0);
    i = 1;
    while (str[i] && str[i] != '=')
    {
        if (!ft_isalnum(str[i]) && str[i] != '_')
            return (0);
        i++;
    }
    return (1);
}

int	is_numeric(const char *str)
{
	int	i;

	i = 0;
	if (str[0] == '-' || str[0] == '+')
		i++;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

void	print_exit_error(char *arg, char *message)
{
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	ft_putstr_fd(arg, STDERR_FILENO);
	ft_putstr_fd(": ", STDERR_FILENO);
	ft_putstr_fd(message, STDERR_FILENO);
	ft_putstr_fd("\n", STDERR_FILENO);
}

int	print_error(char *message, int exit_code)
{
	ft_putstr_fd(message, STDERR_FILENO);
	return (exit_code);
}